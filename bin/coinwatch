#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# The MIT License (MIT)
#
# Copyright (c) 2018 cytopia <cytopia@everythingcli.org>

'''
Coinwatch is a low-dependency python[23] client to keep track of your
crypto trades and easily let's you see if you are winning or losing.

No financial aid, support or any other recommendation is provided.
Trade at your own risk! And only invest what you can effort to lose.

Currently supported API's are:
  - coinmarketcap
'''


############################################################
# Imports
############################################################

# Make it work for python2 and python3
from __future__ import print_function
from __future__ import unicode_literals

try:
    # For Python 3.0 and later
    from urllib.request import Request, urlopen
    from urllib.error import URLError, HTTPError
except ImportError:
    # Fall back to Python 2's urllib2
    from urllib2 import Request, urlopen
    from urllib2 import URLError, HTTPError

# Default imports
from decimal import Decimal, getcontext, localcontext
from random import randint
import os
import getopt
import sys
import re
import json
import yaml

# Force Python2 to use utf8
try:
    reload(sys)  # noqa
    sys.setdefaultencoding('utf8')
except Exception:
    # Not required and won't work on Python3, so
    # do not break on error, but just be silent.
    pass


############################################################
# Globals
############################################################

NAME = 'coinwatch'
AUTHOR = 'cytopia'
VERSION = '0.7'
API_URL = 'https://api.coinmarketcap.com/v1/ticker/?limit=0'


# Row settings
COL_SETTINGS = {
    # colname    #col width    #col align     #precision   #color          #headline
    'name':      {'width': 13, 'align': '<', 'prec': None, 'color': False, 'head': 'CURRENCY'},
    'date':      {'width': 10, 'align': '<', 'prec': None, 'color': False, 'head': 'BUY DATE'},
    'buyprice':  {'width': 14, 'align': '>', 'prec':    6, 'color': False, 'head': '$ BUY PRICE/c'},
    'diffprice': {'width': 15, 'align': '>', 'prec':    6, 'color': True, 'head': '$ DIFF PRICE/c'},
    'nowprice':  {'width': 14, 'align': '>', 'prec':    6, 'color': False, 'head': '$ NOW PRICE/c'},
    'amount':    {'width': 16, 'align': '>', 'prec':    6, 'color': False, 'head': 'NUM COINS'},
    'invest':    {'width': 10, 'align': '>', 'prec':    2, 'color': False, 'head': '$ INVEST'},
    'wealth':    {'width': 10, 'align': '>', 'prec':    2, 'color': False, 'head': '$ WEALTH'},
    'profit':    {'width': 12, 'align': '>', 'prec':    2, 'color': True, 'head': '$ PROFIT'},
    'percent':   {'width':  7, 'align': '>', 'prec':    1, 'color': False, 'head': 'PERCENT'}
}
# All available columns
COL_AVAILABLE = [
    'name',
    'date',
    'buyprice',
    'diffprice',
    'nowprice',
    'amount',
    'invest',
    'wealth',
    'profit',
    'percent'
]
# Default columns to display if not otherwise overwritten via
# configuration file or command line arguments
COL_DEFAULT = [
    'name',
    'date',
    'buyprice',
    'diffprice',
    'nowprice',
    'amount',
    'invest',
    'wealth',
    'profit',
    'percent'
]


EXAMPLE_CONFIG = '''---
#
# coinwatch config
#
# Remote API: https://api.coinmarketcap.com/v1/ticker/?limit=0
#
#
# Config file description
# -----------------------
# trades:
#   # CURRENCY_ID is found by looking up the 'id' key from
#   # https://api.coinmarketcap.com/v1/ticker/?limit=0
#   CURRENCY_ID:  # <-- [array]       Each currency will hold a list of trades
#     - amount:   # <-- [decimal]     [1] How many coins for that currency were bought
#       invest:   # <-- [decimal]     [1] How much money was spent on all coins
#       price:    # <-- [decimal]     [1] Price for 1 coin on that date
#       date:     # <-- [yyyy-mm-dd]  When was that bought
#
# [1] IMPORTANT: Only always specify two of 'amount', 'invest' and 'price'.
#                The third value will always be calculated from the other two.
#
# [1] Trades can/must be configured in three different ways:
# Option-1
#     amount: how many coins bought
#     invest: how much money spent on all coins
# Option-2
#     amount: how many coins bought
#     price:  price for one coin
# Option-3
#     invest: how much money spent on all coins
#     price:  price for one coin

# Example config:
# ---------------

# Configure coinwatch
config:
  # Configure what columns to display and in what order.
  # To see all available columns view help: $ coinwatch --help
  # Columns specified via command line (-r) take precedence
  columns: name date buyprice diffprice nowprice amount invest wealth profit percent
  # Specify your table border style
  # Available values: thin, thick and ascii
  # Use ascii if you want to further process the output of this application
  table: thin

# Configure your purchases
trades:
  bitcoin:
    # Options-1
    - amount:  5.323
      invest:  35432.23
      date:    2017-12-05
    # Options-2
    - amount:  0.001
      price:   110323.54
      date:    2018-01-27
    # Options-3
    - invest:  100
      price:   110323.54
      date:    2018-01-27
  ethereum:
    - amount:  20
      price:   1070
      date:    2017-12-05
  iota: []
'''


############################################################
# Class: Color
############################################################

class Color(object):
    '''Class that returns shell color codes if desired.'''

    def __init__(self, enable):
        '''Enable or disable color support'''
        if enable:
            self.__clr_blue = '\033[94m'
            self.__clr_green = '\033[92m'
            self.__clr_yellow = '\033[93m'
            self.__clr_red = '\033[91m'
            self.__clr_reset = '\033[0m'
        else:
            self.__clr_blue = ''
            self.__clr_green = ''
            self.__clr_yellow = ''
            self.__clr_red = ''
            self.__clr_reset = ''

    def blue(self):
        '''Return blue color code'''
        return self.__clr_blue

    def green(self):
        '''Return green color code'''
        return self.__clr_green

    def yellow(self):
        '''Return yellow color code'''
        return self.__clr_yellow

    def red(self):
        '''Return red color code'''
        return self.__clr_red

    def reset(self):
        '''Return reset color code'''
        return self.__clr_reset


############################################################
# Class: Num
############################################################

class Num(object):
    '''Wrapper to ensure correct variable type for numbers'''

    __precision = 45

    @staticmethod
    def __num(number):
        '''Convert to correct format'''
        return Decimal(str(number))

    @staticmethod
    def __zero():
        '''Get zero'''
        return Num.__num(0)

    @staticmethod
    def get(number):
        '''Make sure to use Decimal'''
        return Num.__num(number)

    @staticmethod
    def sum(num1, num2):
        '''Addition'''
        with localcontext() as ctx:
            ctx.prec = Num.__precision
            return Num.__num(num1) + Num.__num(num2)

    @staticmethod
    def sub(num1, num2):
        '''Substraction'''
        with localcontext() as ctx:
            ctx.prec = Num.__precision
            return Num.__num(num1) - Num.__num(num2)

    @staticmethod
    def mul(num1, num2):
        '''Multiplication'''
        with localcontext() as ctx:
            ctx.prec = Num.__precision
            return Num.__num(num1) * Num.__num(num2)

    @staticmethod
    def div(num1, num2):
        '''Division'''
        with localcontext() as ctx:
            ctx.prec = Num.__precision
            if Num.iszero(num2):
                return Num.__num(getcontext().Emax)
            return Num.__num(num1) / Num.__num(num2)

    @staticmethod
    def iszero(number):
        '''Check if number is zero'''
        with localcontext() as ctx:
            ctx.prec = Num.__precision
            return bool(Num.__num(number) == Num.__zero())

    @staticmethod
    def percent(whole, part):
        '''Percent'''
        return Num.div(
            Num.mul(100, whole),
            part
        )

    @staticmethod
    def round(number, precision):
        '''Round a number to the given precision'''
        with localcontext() as ctx:
            ctx.prec = Num.__precision
            # E.g.: precision=3: '1.000'
            quantizer = Decimal(str('1.' + str('0' * precision)))
            return Num.__num(number).quantize(quantizer)

    @staticmethod
    def to_string(number, precision):
        '''Return string value and round to Xth precision'''
        number = Num.round(number, precision)
        return ('{0:,.' + str(precision) + 'f}').format(number)


############################################################
# Class: Table
############################################################

class Table(object):
    '''Custom command line table drawer class'''

    # Default column width if not set
    __def_width = 10

    # Default align if not set per column
    __def_align = '<'  # Valid: '<' (left), '=' (center), '>' (right)

    # Col formatter
    __col_widths = []
    __col_aligns = []

    # Row formatter used by format()
    __row_format = None
    __sep_format = None
    __top_format = None
    __bot_format = None

    # Available table border styles
    __sym_border = {
        'ascii': {
            'top-lft': '|',
            'top-rgt': '|',
            'top-cen': '-',
            'mid-lft': '|',
            'mid-rgt': '|',
            'mid-cen': '|',
            'bot-lft': '|',
            'bot-rgt': '|',
            'bot-cen': '-',
            'hor-sep': '-',
            'ver-sep': '|'
        },
        'thin': {
            'top-lft': '┌',
            'top-rgt': '┐',
            'top-cen': '┬',
            'mid-lft': '├',
            'mid-rgt': '┤',
            'mid-cen': '┼',
            'bot-lft': '└',
            'bot-rgt': '┘',
            'bot-cen': '┴',
            'hor-sep': '─',
            'ver-sep': '│'
        },
        'thick': {
            'top-lft': '╔',
            'top-rgt': '╗',
            'top-cen': '╦',
            'mid-lft': '╠',
            'mid-rgt': '╣',
            'mid-cen': '╬',
            'bot-lft': '╚',
            'bot-rgt': '╝',
            'bot-cen': '╩',
            'hor-sep': '═',
            'ver-sep': '║'
        }
    }

    # Actual chosen border symbols (see __init__)
    __sym = dict()

    def __init__(self, rows, border):
        '''Defines the table with number of rows and border style'''
        # Store rows
        self.__rows = rows

        # Set table border style
        if border == 'thin':
            self.__sym = self.__sym_border['thin']
        elif border == 'thick':
            self.__sym = self.__sym_border['thick']
        else:
            self.__sym = self.__sym_border['ascii']

        # Set colum aligns and width with defaults
        self.set_col_aligns()
        self.set_col_widths()

    def __set_row_formats(self, *widths):
        '''
        This prive function sets the row formatter strings.
        It has to be re-called everytime the column widths change.
        '''
        # Get symbols in local var for better readability
        sym = self.__sym

        # Create row format
        row = sym['ver-sep']
        for idx, width in enumerate(widths):
            # Get current alignment
            if self.__col_aligns[idx] == '<':
                align = '<'
            elif self.__col_aligns[idx] == '=':
                align = '='
            elif self.__col_aligns[idx] == '>':
                align = '>'
            else:
                align = self.__def_align

            row += ' {:' + align + str(width) + '} ' + sym['ver-sep']

        self.__row_format = row

        # Create first line separator format (opens table)
        row = sym['top-lft']
        for width in widths:
            row += sym['hor-sep'] + \
                   '{:' + sym['hor-sep'] + '<' + str(width) + '}' + \
                   sym['hor-sep'] + sym['top-cen']

        self.__top_format = row[:-1] + sym['top-rgt']  # Adjust last char

        # Create normal line separator format (between rows)
        row = sym['mid-lft']
        for width in widths:
            row += sym['hor-sep'] + \
                   '{:' + sym['hor-sep'] + '<' + str(width) + '}' + \
                   sym['hor-sep'] + sym['mid-cen']

        self.__sep_format = row[:-1] + sym['mid-rgt']  # Adjust last char

        # Create last line separator format (closes table)
        row = sym['bot-lft']
        for width in widths:
            row += sym['hor-sep'] + \
                   '{:' + sym['hor-sep'] + '<' + str(width) + '}' + \
                   sym['hor-sep'] + sym['bot-cen']

        self.__bot_format = row[:-1] + sym['bot-rgt']  # Adjust last char

    @staticmethod
    def __ansilen(string):
        '''Get string length without ansi escape codes'''
        regex = re.compile(r'\x1B\[[0-?]*[ -/]*[@-~]', re.UNICODE)
        return len(regex.sub('', str(string)))

    def set_col_widths(self, *widths):
        '''
        Set colum widths.
        If colum width is not set, default_width will be used.
        '''
        column_widths = []

        # Store colum widths in array
        for width in widths:
            column_widths.append(width)

        # Fill missing widths with default widths:
        if len(widths) < self.__rows:
            for i in range((self.__rows - len(widths))):
                column_widths.append(self.__def_width)

        # Store widths
        self.__col_widths = column_widths

        # Re-build row-formats on every width reset
        self.__set_row_formats(*column_widths)

    def set_col_aligns(self, *aligns):
        '''
        Set colum alignments.
        If colum align is not set, default_align will be used.
        '''
        column_aligns = []

        # Store colum widths in array
        for align in aligns:
            column_aligns.append(align)

        # Fill missing widths with default widths:
        if len(aligns) < self.__rows:
            for i in range((self.__rows - len(aligns))):
                column_aligns.append(self.__def_align)

        # Store aligns
        self.__col_aligns = column_aligns

        # Re-build row-formats on every align reset
        self.__set_row_formats(*self.__col_widths)

    def row(self, *columns):
        '''
        Get formated row with X arguments (num of colums)

        The columns will automatically fix any ANSI escape sequences.
        In order to do so, the widths will be re-calculated based on the difference
        between the string length with and without ANSI escape sequences.
        Afterwards, the colum widths will be restored to their default.
        This way allows me to use the table with and without ANSI es in strings.
        '''
        # store width for restoring (actual copy operation)
        old_widths = list(self.__col_widths)
        new_widths = list(self.__col_widths)

        # Find ANSI escape sequence length differences
        for idx, col in enumerate(columns):
            # Mismatch found
            if len(str(col)) != Table.__ansilen(col):
                # Add difference to new width
                diff = len(columns[idx]) - Table.__ansilen(columns[idx])
                new_widths[idx] = new_widths[idx] + diff
        # Re-build widths
        self.set_col_widths(*new_widths)

        # Get row format
        row = self.__row_format.format(*columns)

        # Restore widths
        self.set_col_widths(*old_widths)

        # Return the row
        return row

    def sep_first(self):
        '''Get first row separator row'''
        return self.__top_format.format(*['' for i in range(self.__rows)])

    def sep(self):
        '''Get row separator row'''
        return self.__sep_format.format(*['' for i in range(self.__rows)])

    def sep_last(self):
        '''Get last row separator row'''
        return self.__bot_format.format(*['' for i in range(self.__rows)])


############################################################
# Class: Coinwatch
############################################################

class Coinwatch(object):
    '''Coinwatch Class'''

    # General output settings
    __settings = {
        'color': False,    # Colorize output?
        'human': False,    # Humanize number output?
        'table': 'thick',  # Table border style
        'cols': dict()     # Columns to display
    }

    # Specific settings for each column
    __col_settings = dict()

    def __init__(self, settings, col_settings):
        '''Set settings'''
        self.__settings = settings
        self.__col_settings = col_settings

    @staticmethod
    def __get_amount(trade):
        '''Returns amount based on amount, invest and price'''

        if 'amount' in trade:
            return Num.get(trade['amount'])
        # amount needs to be calculated
        invest = Num.get(trade.get('invest', 0))
        price = Num.get(trade.get('price', 0))
        return Num.div(invest, price)

    @staticmethod
    def __get_invest(trade):
        '''Returns invest based on amount, invest and price'''

        if 'invest' in trade:
            return Num.get(trade['invest'])
        # Invest needs to be calculated
        amount = Num.get(trade.get('amount', 0))
        price = Num.get(trade.get('price', 0))
        return Num.mul(price, amount)

    @staticmethod
    def __get_price(trade):
        '''Returns price based on amount, invest and price'''

        if 'price' in trade:
            return Num.get(trade['price'])
        # Price needs to be calculated
        invest = Num.get(trade.get('invest', 0))
        amount = Num.get(trade.get('amount', 0))
        return Num.div(invest, amount)

    @staticmethod
    def __extract_trade_row_values(currency, price, trade):
        '''
        Extract values of one trade list item, calculate all other necessary
        values and combine with current price and crypto name.
        trade: {date, price, invest, amount}
        '''
        amount = Coinwatch.__get_amount(trade)
        invest = Coinwatch.__get_invest(trade)
        buyprice = Coinwatch.__get_price(trade)
        nowprice = Num.get(price)

        # Calculate diffprice, wealth, profit and percent
        diffprice = Num.sub(nowprice, buyprice)
        wealth = Num.mul(nowprice, amount)
        profit = Num.sub(wealth, invest)
        percent = Num.percent(wealth, invest)

        return {
            'name':      currency,
            'date':      str(trade.get('date', '-')),
            'buyprice':  buyprice,
            'diffprice': diffprice,
            'nowprice':  nowprice,
            'amount':    amount,
            'invest':    invest,
            'wealth':    wealth,
            'profit':    profit,
            'percent':   percent
        }

    @staticmethod
    def __humanize_number(number, precision):
        '''Human readable number format'''
        number = str(number)
        fnumber = number.split('.')
        # Does it have decimal places?
        if len(fnumber) == 2:
            # Remove '0' from the rights
            fnumber[1] = fnumber[1].rstrip('0')

            # Have at least two '0' on the right if the precision is equal or higher
            while len(fnumber[1]) < 2 and len(fnumber[1]) < precision:
                fnumber[1] = fnumber[1] + '0'
            # Fill up with spaces (for alignment)
            while len(fnumber[1]) < precision:
                fnumber[1] = fnumber[1] + ' '

            # Reconstruct
            number = fnumber[0] + '.' + fnumber[1]

        return number

    def __format_trade_row_values(self, values):
        '''
        Use extracted trade row value dictionary and format
        it nicely based on given colum settings.
        col_settings   Holds settings for each column
        colorize       Global setting that determines whether to apply colors.
        '''
        # Read settings into var for better readability
        col_settings = self.__col_settings
        colorize = self.__settings['color']
        humanize = self.__settings['human']

        clr = Color(colorize)
        fvalues = dict()
        for val in values:
            fvalues[val] = values[val]

            # 1. Rounding
            if col_settings[val]['prec'] is not None and fvalues[val]:
                fvalues[val] = Num.to_string(values[val], col_settings[val]['prec'])
            # 2. Humanize output
            if humanize:
                fvalues[val] = Coinwatch.__humanize_number(
                    fvalues[val],
                    col_settings[val]['prec']
                )
            # 3. Colorize
            if col_settings[val]['color'] and fvalues[val]:
                if values[val] < 0:
                    fvalues[val] = clr.red() + str(fvalues[val]) + clr.reset()
                else:
                    fvalues[val] = clr.green() + str(fvalues[val]) + clr.reset()
        return fvalues

    def __format_summary_row_values(self, totals):
        '''Format and return the summary row'''
        values = dict()
        values['name'] = 'TOTAL'
        values['date'] = ''
        values['buyprice'] = ''
        values['diffprice'] = ''
        values['nowprice'] = ''
        values['amount'] = ''
        values['invest'] = totals['invest']
        values['wealth'] = totals['wealth']
        values['profit'] = totals['profit']
        values['percent'] = Num.percent(totals['wealth'], totals['invest'])
        return self.__format_trade_row_values(values)

    def print_stats(self, currencies, trades):
        '''Print trading stats in a nice table'''

        # Total accumulated values
        totals = {
            'invest': Decimal('0.0'),
            'wealth': Decimal('0.0'),
            'profit': Decimal('0.0'),
        }

        # Get columns to to display and their settings
        display_columns = self.__settings['cols']
        col_settings = self.__col_settings

        # Initialize the table
        tbl = Table(len(display_columns), self.__settings['table'])
        tbl.set_col_widths(*[col_settings[x]['width'] for x in display_columns])
        tbl.set_col_aligns(*[col_settings[x]['align'] for x in display_columns])

        # Print headline
        print(tbl.sep_first())
        print(tbl.row(*[col_settings[x]['head'] for x in display_columns]))
        print(tbl.sep())

        for currency in currencies:

            # Do we track a currency?
            # (Remote currency is found in local config)
            if currency['id'] in trades:

                name = currency['id']

                # Only proceed if trade happened (defined in config)
                if trades[name]:
                    # Loop over trades in each currency
                    # (Each currency can have multiple trades on different dates/times)
                    for trade in trades[name]:

                        # Extract and format row values
                        values = self.__extract_trade_row_values(name, currency['price_usd'], trade)
                        fvalues = self.__format_trade_row_values(values)

                        # Calculate total accumulated values
                        totals['invest'] = Num.sum(totals['invest'], values['invest'])
                        totals['wealth'] = Num.sum(totals['wealth'], values['wealth'])
                        totals['profit'] = Num.sum(totals['profit'], values['profit'])

                        # Only add column values that are wanted for display
                        row = []
                        for col in display_columns:
                            row.append(fvalues[col])

                        # Print current row
                        print(tbl.row(*row))

                    # Separate only different coins by row separator
                    print(tbl.sep())

        # Print overall summary
        fvalues = self.__format_summary_row_values(totals)

        # Set colums to be displayed
        row = []
        for col in display_columns:
            row.append(fvalues[col])

        print(tbl.row(*row))
        # Close the table
        print(tbl.sep_last())


############################################################
# Helper Functions
############################################################

def logerr(*args):
    '''Error wrapper for print function'''
    print(''.join(map(str, args)), file=sys.stderr)


def random_useragent():
    '''Returns random useragent'''
    useragents = [
        'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0; .NET CLR 1.0.3705)',
        'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; FSL 7.0.5.01003)',
        'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; FSL 7.0.6.01001)',
        'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; FSL 7.0.7.01001)',
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:57.0) Gecko/20100101 Firefox/57.0',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:57.0) Gecko/20100101 Firefox/57.0',
        'Mozilla/5.0 (Windows NT 5.1; rv:13.0) Gecko/20100101 Firefox/13.0.1',
        'Mozilla/5.0 (Windows NT 5.1; rv:13.0) Gecko/20100101 Firefox/13.0.1',
        'Mozilla/5.0 (Windows NT 5.1; rv:5.0.1) Gecko/20100101 Firefox/5.0.1',
        'Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko',
        'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:12.0) Gecko/20100101 Firefox/12.0',
        'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/20100101 Firefox/13.0.1',
        'Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:57.0) Gecko/20100101 Firefox/57.0',
        'Mozilla/5.0 (Windows NT 6.1; rv:5.0) Gecko/20100101 Firefox/5.02',
        'Mozilla/5.0 (X11; Linux x86_64; rv:57.0) Gecko/20100101 Firefox/57.0',
        'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:57.0) Gecko/20100101 Firefox/57.0',
        'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)',
        'Opera/9.80 (Windows NT 5.1; U; en) Presto/2.10.289 Version/12.01'
    ]
    index = randint(0, len(useragents)-1)
    return useragents[index]


def fetch_url(url):
    '''Fetch body as text from http url'''

    useragent = random_useragent()
    req = Request(url, headers={'User-Agent': useragent})
    try:
        response = urlopen(req)
    except HTTPError as err:
        logerr('[ERR] Cannot connect to %s' % (url))
        logerr('[ERR] Error code: ', err.code)
        return ''
    except URLError as err:
        logerr('[ERR] Cannot connect to %s' % (url))
        logerr('[ERR] Reason:', err.reason)
        return ''
    else:
        return response.read().decode('utf-8')


def to_yaml(string):
    '''Convert string to yaml'''
    try:
        data = yaml.load(string)
    except yaml.YAMLError as err:
        logerr('[ERR] Cannot convert string to yaml')
        logerr('[ERR] ', str(err))
        return dict()
    else:
        if data is None:
            return dict()
    return data


def to_json(string):
    '''Convert string to json'''
    try:
        data = json.loads(string)
    except ValueError as err:
        logerr('[ERR] Cannot convert to json')
        logerr('[ERR] ', str(err))
        return dict()
    else:
        if data is None:
            return dict()
    return data


############################################################
# Project Functions
############################################################

def print_version():
    '''Show program version'''
    print(NAME, 'v' + VERSION)
    print('Using Python ' + str(sys.version_info[0]) + '.' + str(sys.version_info[1]))
    print('MIT License - Copyright (c) 2018 cytopia')
    print('https://github.com/cytopia/coinwatch')


def print_help():
    '''Show program help'''
    print('''Usage: %s [-crtnhv]
       %s [--help]
       %s [--version]

%s is a low-dependency python[23] client to keep track of your crypto trades
and easily let's you see if you are winning or losing. If you are not actually
trading you can use it to simulate purchases and see what would have happened if.

OPTIONS:
  -c, --config   Specify path of an alternative configuration file. Store
                 different configurations in different configuration files in
                 order to simulate multiple profiles.
                 Examples:
                   -c path/to/conf/john.yml
                   -c path/to/conf/jane.yml
  -r, --row      Specify the order and columns to use in a row. In case you
                 dont need all columns to be shown or want a different order of
                 columns, use this argument to specify it.
                 Available columns:
                   %s
                 Examples:
                   -r "coin date profit percent"
                   -r "coin buyprice nowprice amount wealth"
  -t, --table    Specify different table border. In case you need to process
                 the output of this tool use 'ascii'.
                 Available values: 'thin', 'thick' and 'ascii'.
                 The default is 'thin'.
                 Examples:
                   -t thin
                   -t thick
                   -t ascii
  -n, --nocolor  Disable shell colors. This is useful if you want to further
                 process the output of this program.
  -h, --human    Alternative human readable number format.
  -v, --verbose  Be verbose.

NOTE:
  No financial aid, support or any other recommendation is provided.
  Trade at your own risk! And only invest what you can effort to lose.

CONFIGURATION:
  When starting %s for the first time a base configuration file will be
  created in ~/.config/%s/config.yml''' %
          (NAME, NAME, NAME, NAME, ' '.join(COL_AVAILABLE), NAME, NAME))


def get_config_path():
    '''Get path of local config file'''
    home = os.path.expanduser('~')
    conf = os.path.join(home, '.config', NAME, 'config.yml')
    return conf


def read_config(path):
    '''Read trades from local yaml configuration file'''
    if not path:
        path = get_config_path()

    data = dict()
    if os.path.isfile(path):
        with open(path, 'r') as stream:
            data = to_yaml(stream)

    # Fill up defaults
    if 'trades' not in data:
        data['trades'] = dict()
    if 'config' not in data:
        data['config'] = dict()

    return data


def validate_config(config):
    '''Validate configuration file'''

    # Validate config
    if 'config' in config:
        # Columns
        if 'columns' in config['config'] and config['config']['columns']:
            for col in config['config']['columns'].split(' '):
                if col not in COL_AVAILABLE:
                    logerr('[ERR] Invalid colum name in config: \'' + col + '\'')
                    logerr('[ERR] Valid names: ' + ', '.join(COL_AVAILABLE))
                    sys.exit(2)
        # Table border
        if 'table' in config['config'] and config['config']['table']:
            if config['config']['table'] not in ('thin', 'thick', 'ascii'):
                logerr('[ERR] Invalid table border style in config: ' + config['config']['table'])
                logerr('[ERR] Allowed values: thin, thick and ascii')
                sys.exit(2)

    # Validate trades
    if not config['trades']:
        print('No trades found, check your config')
        sys.exit(0)


def bootstrap():
    '''Bootstrap the application'''
    conf_file = get_config_path()
    conf_dir = os.path.dirname(conf_file)

    if not os.path.isfile(conf_file):
        if not os.path.isdir(conf_dir):
            os.makedirs(conf_dir)

        pfile = open(conf_file, 'w')
        pfile.write(str(EXAMPLE_CONFIG))
        pfile.close()


def parse_args(argv, settings):
    '''Parse command line arguments.'''

    # Define command line options
    try:
        opts, argv = getopt.getopt(argv, 'c:r:t:nhv', [
            'version',
            'help',
            'config=',
            'row=',
            'table=',
            'nocolor',
            'human',
            'verbose'
        ])
    except getopt.GetoptError as err:
        logerr('[ERR] ', err)
        logerr('Type --help for help')
        sys.exit(2)

    # Get command line options
    for opt, arg in opts:
        # Show help screen
        if opt == '--help':
            print_help()
            sys.exit()
        # Show version
        elif opt == '--version':
            print_version()
            sys.exit()
        # Custom rows to display in the given order
        elif opt in ('-r', '--row'):
            for col in arg.split(' '):
                if col not in COL_AVAILABLE:
                    logerr('[ERR] Invalid colum name: \'' + col + '\'')
                    logerr('[ERR] Valid names: ' + ', '.join(COL_AVAILABLE))
                    sys.exit(2)
            settings['cols'] = arg.split()
        # Choose table border
        elif opt in ('-t', '--table'):
            if arg not in('thin', 'thick', 'ascii'):
                logerr('[ERR] Invalid table border style: \'' + arg + '\'')
                logerr('[ERR] Allowed values: thin, thick and ascii')
                sys.exit(2)
            settings['table'] = arg
        # Use different config file
        elif opt in ('-c', '--config'):
            if not os.path.isfile(arg):
                logerr('[ERR] ' + opt + ' specified config does not exist: ' + arg)
                sys.exit(2)
            settings['path'] = arg
        # Disable color
        elif opt in ('-n', '--nocolor'):
            settings['color'] = False
        # Enable human readable number format
        elif opt in ('-h', '--human'):
            settings['human'] = True
        # Verbose output
        elif opt in ('-v', '--verbose'):
            settings['verbose'] = True

    return settings


############################################################
# Main Function
############################################################

def main(argv):
    '''Main entrypoint.'''

    # Default settings if not otherwise specified via config or cmd args
    settings = {
        'path':    None,     # Path to configuration file
        'color':   True,     # Colorize output
        'human':   False,    # Human readable number format
        'verbose': False,    # Verbosity?
        'table':   None,     # Table border style
        'cols':    dict()    # What columns in what order to display
    }

    # Bootstrap application (creating config & dir)
    bootstrap()

    # Get configuration from command line arguments
    settings = parse_args(argv, settings)

    # Read and validate configuration file
    config = read_config(settings['path'])
    validate_config(config)

    # Apply column settings
    if settings['cols']:
        # Set via cmd args, all good
        pass
    elif 'columns' in config['config'] and config['config']['columns']:
        # Available in configuration file
        settings['cols'] = config['config']['columns'].split()
    else:
        # Nowhere set, use defaults
        settings['cols'] = COL_DEFAULT

    # Apply table border settings
    if settings['table']:
        # Set via cmd args, all good
        pass
    elif 'table' in config['config'] and config['config']['table']:
        # Available in configuration file
        settings['table'] = config['config']['table']
    else:
        # Nowhere set, use defaults
        settings['table'] = 'thin'

    # Get remote price info
    currencies = to_json(fetch_url(API_URL))

    # Initialize and run Coinwatch
    cowa = Coinwatch({
        'color': settings['color'],  # Colorize output?
        'human': settings['human'],  # Humanize number output?
        'table': settings['table'],  # Table border style
        'cols': settings['cols']     # Columns to display
    }, COL_SETTINGS)
    cowa.print_stats(currencies, config['trades'])


############################################################
# Main Entry Point
############################################################

if __name__ == '__main__':
    main(sys.argv[1:])
