#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# The MIT License (MIT)
#
# Copyright (c) 2018 cytopia <cytopia@everythingcli.org>

'''
Coinwatch is a low-dependency python[23] client to keep track of your
crypto trades and easily let's you see if you are winning or losing.

No financial aid, support or any other recommendation is provided.
Trade at your own risk! And only invest what you can effort to lose.

Currently supported API's are:
  - coinmarketcap
'''


############################################################
# Imports
############################################################

# Make it work for python2 and python3
from __future__ import print_function

try:
    # For Python 3.0 and later
    from urllib.request import Request, urlopen
    from urllib.error import URLError, HTTPError
except ImportError:
    # Fall back to Python 2's urllib2
    from urllib2 import Request, urlopen
    from urllib2 import URLError, HTTPError

# Default imports
from decimal import Decimal
from random import randint
import os
import getopt
import sys
import json
import yaml

# Force Python2 to use utf8
try:
    reload(sys)
    sys.setdefaultencoding('utf8')
except:
    pass


############################################################
# Globals
############################################################

NAME = 'coinwatch'
AUTHOR = 'cytopia'
VERSION = '0.3'
API_URL = 'https://api.coinmarketcap.com/v1/ticker/?limit=0'


EXAMPLE_CONFIG = '''
---
#
# coinwatch config
#
# Remote API: https://api.coinmarketcap.com/v1/ticker/?limit=0
#
#
# Config file description
# -----------------------
# trades:
#   # CURRENCY_ID is found by looking up the 'id' key from
#   # https://api.coinmarketcap.com/v1/ticker/?limit=0
#   CURRENCY_ID:  # <-- [array]       Each currency will hold a list of trades
#     - amount:   # <-- [decimal]     How many coins for that currency were bought
#       price:    # <-- [decimal]     Price for 1 coin of that currency
#       date:     # <-- [yyyy-mm-dd]  When was that bought
#
#
# Config file example:
# --------------------
# trades:
#   bitcoin:
#     - amount:  5.323
#       price:   10100.52
#       date:    2017-12-05
#     - amount:  0.001
#       price:   110323.54
#       date:    2018-01-27
#   ethereum:
#     - amount:  20
#       price:   1070
#       date:    2017-12-05
#   iota: []
'''


############################################################
# Class
############################################################

class Color(object):
    '''Class that returns shell color code if desired.'''

    def __init__(self, enable):
        '''Enable or disable color support'''
        if enable:
            self.__clr_blue = '\033[94m'
            self.__clr_green = '\033[92m'
            self.__clr_yellow = '\033[93m'
            self.__clr_red = '\033[91m'
            self.__clr_reset = '\033[0m'
        else:
            self.__clr_blue = ''
            self.__clr_green = ''
            self.__clr_yellow = ''
            self.__clr_red = ''
            self.__clr_reset = ''

    def blue(self):
        '''Return blue color code'''
        return self.__clr_blue

    def green(self):
        '''Return green color code'''
        return self.__clr_green

    def yellow(self):
        '''Return yellow color code'''
        return self.__clr_yellow

    def red(self):
        '''Return red color code'''
        return self.__clr_red

    def reset(self):
        '''Return reset color code'''
        return self.__clr_reset


class Table(object):
    '''Custom command line table drawer class'''

    # Default column width if not set
    __def_width = 10
    # Row formatter used by format()
    __row_format = u''
    __sep_format = u''
    __top_format = u''
    __bot_format = u''

    # Create table out of these chars
    __sym_text = {
        'top-lft': '|',
        'top-rgt': '|',
        'top-cen': '-',
        'mid-lft': '|',
        'mid-rgt': '|',
        'mid-cen': '|',
        'bot-lft': '|',
        'bot-rgt': '|',
        'bot-cen': '-',
        'hor-sep': '-',
        'ver-sep': '|'
    }
    __sym_ext = {
        'top-lft': u'┌',
        'top-rgt': u'┐',
        'top-cen': u'┬',
        'mid-lft': u'├',
        'mid-rgt': u'┤',
        'mid-cen': u'┼',
        'bot-lft': u'└',
        'bot-rgt': u'┘',
        'bot-cen': u'┴',
        'hor-sep': u'─',
        'ver-sep': u'│'
    }
    __sym = dict()

    def __init__(self, rows, textmode):
        '''Defines the table with number of rows'''
        self.rows = rows
        # Set table style
        if textmode:
            self.__sym = self.__sym_text
        else:
            self.__sym = self.__sym_ext
        # Set colum width with default widths
        self.set_col_widths()


    def set_col_widths(self, *widths):
        '''
        Set colum widths.
        If colum width is not set, default_width will be used
        '''
        colum_width = []

        # Store colum widths in array
        for width in widths:
            colum_width.append(width)

        # Fill missing widths with default widths:
        if len(widths) < self.rows:
            for i in range((self.rows - len(widths))):
                colum_width.append(self.__def_width)

        # Create row format
        self.__row_format = self.__sym['ver-sep']
        for width in colum_width:
            self.__row_format += u' {:<' + str(width) + u'} ' + self.__sym['ver-sep']

        # Create top line separator format
        self.__top_format = self.__sym['top-lft']
        for width in colum_width:
            self.__top_format += u'' + self.__sym['hor-sep'] \
                                 + u'{:' + self.__sym['hor-sep'] + u'<' + str(width) + u'}' \
                                 + self.__sym['hor-sep'] + self.__sym['top-cen']
        self.__top_format = self.__top_format[:-1] + self.__sym['top-rgt']

        # Create line separator format
        self.__sep_format = self.__sym['mid-lft']
        for width in colum_width:
            self.__sep_format += u'' + self.__sym['hor-sep'] \
                                 + u'{:' + self.__sym['hor-sep'] + u'<' + str(width) + u'}' \
                                 + self.__sym['hor-sep'] + self.__sym['mid-cen']
        self.__sep_format = self.__sep_format[:-1] + self.__sym['mid-rgt']

        # Create bottom line separator format
        self.__bot_format = self.__sym['bot-lft']
        for width in colum_width:
            self.__bot_format += u'' + self.__sym['hor-sep'] \
                                 + u'{:' + self.__sym['hor-sep'] + u'<' + str(width) + u'}' \
                                 + self.__sym['hor-sep'] + self.__sym['bot-cen']
        self.__bot_format = self.__bot_format[:-1] + self.__sym['bot-rgt']

    def row(self, *colums):
        '''Get formated row with X arguments (num of colums)'''
        return self.__row_format.format(*colums)

    def sep_first(self):
        '''Get first row separator row'''
        return self.__top_format.format(*[u'' for i in range(self.rows)])

    def sep(self):
        '''Get row separator row'''
        return self.__sep_format.format(*[u'' for i in range(self.rows)])

    def sep_last(self):
        '''Get last row separator row'''
        return self.__bot_format.format(*[u'' for i in range(self.rows)])


############################################################
# Helper Functions
############################################################

def logerr(*args):
    '''Error wrapper for print function'''
    print(''.join(map(str, args)), file=sys.stderr)


def random_useragent():
    '''Returns random useragent'''
    useragents = [
        'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0; .NET CLR 1.0.3705)',
        'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; FSL 7.0.5.01003)',
        'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; FSL 7.0.6.01001)',
        'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; FSL 7.0.7.01001)',
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:57.0) Gecko/20100101 Firefox/57.0',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:57.0) Gecko/20100101 Firefox/57.0',
        'Mozilla/5.0 (Windows NT 5.1; rv:13.0) Gecko/20100101 Firefox/13.0.1',
        'Mozilla/5.0 (Windows NT 5.1; rv:13.0) Gecko/20100101 Firefox/13.0.1',
        'Mozilla/5.0 (Windows NT 5.1; rv:5.0.1) Gecko/20100101 Firefox/5.0.1',
        'Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko',
        'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:12.0) Gecko/20100101 Firefox/12.0',
        'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/20100101 Firefox/13.0.1',
        'Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:57.0) Gecko/20100101 Firefox/57.0',
        'Mozilla/5.0 (Windows NT 6.1; rv:5.0) Gecko/20100101 Firefox/5.02',
        'Mozilla/5.0 (X11; Linux x86_64; rv:57.0) Gecko/20100101 Firefox/57.0',
        'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:57.0) Gecko/20100101 Firefox/57.0',
        'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)',
        'Opera/9.80 (Windows NT 5.1; U; en) Presto/2.10.289 Version/12.01'
    ]
    index = randint(0, len(useragents)-1)
    return useragents[index]


def fetch_url(url):
    '''Fetch body as text from http url'''

    useragent = random_useragent()
    req = Request(url, headers={'User-Agent': useragent})
    try:
        response = urlopen(req)
    except HTTPError as err:
        logerr('[ERR] Cannot connect to %s' % (url))
        logerr('[ERR] Error code: ', err.code)
        return ''
    except URLError as err:
        logerr('[ERR] Cannot connect to %s' % (url))
        logerr('[ERR] Reason:', err.reason)
        return ''
    else:
        return response.read().decode('utf-8')


def to_yaml(string):
    '''Convert string to yaml'''
    try:
        data = yaml.load(string)
    except yaml.YAMLError as err:
        logerr('[ERR] Cannot convert string to yaml')
        logerr('[ERR] ', str(err))
        return dict()
    else:
        if data is None:
            return dict()
    return data


def to_json(string):
    '''Convert string to json'''
    try:
        data = json.loads(string)
    except ValueError as err:
        logerr('[ERR] Cannot convert to json')
        logerr('[ERR] ', str(err))
        return dict()
    else:
        if data is None:
            return dict()
    return data


def percent(total, part, default):
    '''Calculate percent with default value in case part is zero'''
    if part == 0:
        return default

    return 100 * total / part


############################################################
# Project Functions
############################################################

def print_version():
    '''Show program version'''
    print(NAME, 'v' + VERSION)
    print('Using Python ' + str(sys.version_info[0]) + '.' + str(sys.version_info[1]))
    print('MIT License - Copyright (c) 2018 cytopia')
    print('https://github.com/cytopia/coinwatch')


def print_help():
    '''Show program help'''
    print('''Usage: %s [-vhctf]
       %s [--version] [--help] [--config <path>] [--text] [--format]

%s is a low-dependency python[23] client to keep track of your crypto trades
and easily let's you see if you are winning or losing.

OPTIONS:
    -v, --version  Show version and exit
    -h, --help     Show this help dialog and exit
    -c, --config   Specify path of an alternative configuration file.
    -t, --text     Do not display colors or fancy ascii chars. Text mode is
                   designed to use the output of this program as input for
                   other programs. Such as:
                     $ watch --interval=10 'coinwatch -t'
    -f, --format   Alternative format for displaying large numbers.
                   Try it out, might be more readable.

NOTE:
    No financial aid, support or any other recommendation is provided.
    Trade at your own risk! And only invest what you can effort to lose.

API:
    Currently supported remote price and coin API's are:
      - coinmarketcap

CONFIGURATION:
    When starting %s for the first time a base configuration file will be
    created in ~/.config/%s/config.yml.
    You should edit this file and add your trades:
      - What currency
      - When bought
      - How much bought
      - Price for 1 coin of currency at that date''' % (NAME, NAME, NAME, NAME, NAME))


def fdec(number, length, places, settings, colorize):
    '''
    Custom decimal format wrapper
    number:   the decinaml number to format
    length:   total length including dot and dec places
    places:   how many decimal places to show
    settings: Settings
    colorize: Colorize positive vs. negative numbers
    returns string
    '''
    if not isinstance(number, Decimal):
        number = Decimal(str(number))

    # Correctly round our Decimal
    number = number.quantize(Decimal(('{0:.' + str(places) + 'f}').format(1)))

    # Correctly format our Decimal
    fnumber = ('{0:,.' + str(places) + 'f}').format(number)

    # Remove all decimal places that are 0 and refill them up with spaces
    # However, keep at least one and max two zeros if using decimal places.
    # This will cause a more readable output and numbers will look like this:
    #  22.00
    #   2.30
    #   2.31432
    # 143.0001
    if places > 0 and settings['format']:
        fnumber = fnumber.rstrip('0')
        fnumber = fnumber.split('.')
        while len(fnumber[1]) < 2 and len(fnumber[1]) < places:
            fnumber[1] = fnumber[1] + '0'
        while len(fnumber[1]) < places:
            fnumber[1] = fnumber[1] + ' '

        fnumber = fnumber[0] + '.' + fnumber[1]

    if colorize and not settings['text']:
        clr = Color(not settings['text'])
        if number < 0:
            return clr.red() + ('{:>' + str(length) + '}').format(fnumber) + clr.reset()
        return clr.green() + ('{:>' + str(length) + '}').format(fnumber) + clr.reset()
    return ('{:>' + str(length) + '}').format(fnumber)


def get_config_path():
    '''Get path of local config file'''
    home = os.path.expanduser('~')
    conf = os.path.join(home, '.config', NAME, 'config.yml')
    return conf


def get_trades(settings):
    '''Read trades from local yaml configuration file'''
    if settings['config']:
        path = settings['config']
    else:
        path = get_config_path()

    if os.path.isfile(path):
        with open(path, 'r') as stream:
            data = to_yaml(stream)
            if 'trades' in data:
                return data['trades']

    return dict()


def print_stats(currencies, trades, settings):
    '''Print trading stats in a nice table'''

    # Total accumulated values
    totals = {
        'invest': Decimal('0.0'),
        'wealth': Decimal('0.0'),
        'win':    Decimal('0.0'),
    }

    # Row definition
    rows = [
        {'width': 13, 'head': 'COIN'},
        {'width': 10, 'head': 'BUY DATE'},
        {'width': 14, 'head': 'BUY PRICE/c'},
        {'width': 14, 'head': 'NOW PRICE/c'},
        {'width': 15, 'head': 'AMOUNT'},
        {'width': 10, 'head': 'INVEST'},
        {'width': 10, 'head': 'WEALTH'},
        {'width': 12, 'head': 'WIN / LOSS'},
        {'width':  7, 'head': 'PERCENT'}
    ]

    # Initialize the table
    tbl = Table(len(rows), settings['text'])
    tbl.set_col_widths(*[x['width'] for x in rows])

    # Print headline
    print(tbl.sep_first())
    print(tbl.row(*[x['head'] for x in rows]))
    print(tbl.sep())

    for currency in currencies:

        # Do we track a currency?
        # (Remote currency is found in local config)
        if currency['id'] in trades:

            name = currency['id']

            # Only proceed if trade happened (defined in config)
            if trades[name]:
                # Loop over trades in each currency
                # (Each currency can have multiple trades on different dates/times)
                for trade in trades[name]:
                    # Extract values
                    date = str(trade.get('date', 'yyyy-mm-dd'))
                    amount = Decimal(str(trade.get('amount', '0.0')))
                    buy_price = Decimal(str(trade.get('price', '0.0')))
                    now_price = Decimal(str(currency['price_usd']))

                    # Calculate invest, own and win
                    inv = buy_price * amount
                    own = now_price * amount
                    win = own - inv

                    # Print current row
                    print(tbl.row(
                        name,
                        date,
                        fdec(buy_price, rows[2]['width'], 6, settings, False),
                        fdec(now_price, rows[3]['width'], 6, settings, False),
                        fdec(amount, rows[4]['width'], 8, settings, False),
                        fdec(inv, rows[5]['width'], 2, settings, False),
                        fdec(own, rows[6]['width'], 2, settings, False),
                        fdec(win, rows[7]['width'], 2, settings, True),
                        fdec(percent(now_price, buy_price, 0), rows[8]['width'], 1, settings, False)
                    ))

                    # Add accumulated values
                    totals['invest'] += inv
                    totals['wealth'] += own
                    totals['win'] += win

                # Separate only different coins by row separator
                print(tbl.sep())

    # Print overall summary
    print(tbl.row(
        'TOTAL',
        '',
        '',
        '',
        '',
        fdec(totals['invest'], rows[5]['width'], 2, settings, False),
        fdec(totals['wealth'], rows[6]['width'], 2, settings, False),
        fdec(totals['win'], rows[7]['width'], 2, settings, True),
        fdec(percent(totals['wealth'], totals['invest'], 0), rows[8]['width'], 1, settings, False)
    ))
    # Close the table
    print(tbl.sep_last())


def bootstrap():
    '''Bootstrap the application'''
    conf_file = get_config_path()
    conf_dir = os.path.dirname(conf_file)

    if not os.path.isfile(conf_file):
        if not os.path.isdir(conf_dir):
            os.makedirs(conf_dir)

        pfile = open(conf_file, 'w')
        pfile.write(str(EXAMPLE_CONFIG))
        pfile.close()


def parse_args(argv, settings):
    '''Parse command line arguments.'''

    # Define command line options
    try:
        opts, argv = getopt.getopt(argv, 'vhc:tf', ['version', 'help', 'config=', 'text', 'format'])
    except getopt.GetoptError as err:
        logerr('[ERR] ', err)
        logerr('Type --help for help')
        sys.exit(2)

    # Get command line options
    for opt, arg in opts:
        if opt in ('-h', '--help'):
            print_help()
            sys.exit()
        elif opt in ('-v', '--version'):
            print_version()
            sys.exit()
        elif opt in ('-t', '--text'):
            settings['text'] = True
        elif opt in ('-f', '--format'):
            settings['format'] = True
        elif opt in ('-c', '--config'):
            if not os.path.isfile(arg):
                logerr('[ERR] ' + opt + ' specified config does not exist: ' + arg)
                sys.exit(2)
            settings['config'] = arg

    return settings


############################################################
# Main Function
############################################################

def main(argv):
    '''Main entrypoint.'''

    # Default settings if not otherwise specified via cmd args
    settings = {
        'text': False,
        'config': None,
        'format': False
    }
    # Overwrite settings
    settings = parse_args(argv, settings)

    # bootstrap (creating config & dir)
    bootstrap()

    # Read local trading config
    trades = get_trades(settings)

    if not trades:
        if settings['config']:
            conf = settings['config']
        else:
            conf = get_config_path()
        print('No trades found, check your config:', conf)
        sys.exit(0)

    # Get remote price info
    currencies = to_json(fetch_url(API_URL))
    # Show trading stats
    print_stats(currencies, trades, settings)


############################################################
# Main Entry Point
############################################################

if __name__ == '__main__':
    main(sys.argv[1:])
